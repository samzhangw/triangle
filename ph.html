<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI è³½å±€æ¼”è®Šåˆ†æå™¨ (Proç‰ˆ)</title>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@400;500;700&family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    
    <script src="https://cdn.sheetjs.com/xlsx-0.19.3/package/dist/xlsx.full.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>

    <style>
        :root { 
            --primary: #3b82f6; 
            --primary-dark: #2563eb;
            --success: #10b981;
            --purple: #8b5cf6;
            --bg: #f0f4f8; 
            --card-bg: #ffffff; 
            --text-main: #1e293b;
            --text-sec: #64748b;
        }

        body { 
            font-family: 'Inter', 'Noto Sans TC', sans-serif; 
            background: var(--bg); 
            padding: 40px 20px; 
            color: var(--text-main); 
            line-height: 1.6;
        }

        .container { max-width: 1200px; margin: 0 auto; }

        /* --- Header å€å¡Š --- */
        header { text-align: center; margin-bottom: 40px; }
        h1 { 
            font-size: 2.5rem; color: var(--text-main); margin-bottom: 10px; font-weight: 800;
            background: -webkit-linear-gradient(45deg, #2563eb, #8b5cf6);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        .desc { color: var(--text-sec); font-size: 1.1rem; }

        /* --- ä¸Šå‚³å€ --- */
        .upload-area {
            background: var(--card-bg); 
            border: 3px dashed #cbd5e1; 
            border-radius: 20px; 
            padding: 3rem; 
            text-align: center; 
            cursor: pointer; 
            transition: all 0.3s ease;
            margin-bottom: 30px;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.05);
        }
        .upload-area:hover { 
            border-color: var(--primary); 
            background: #eff6ff; 
            transform: translateY(-2px);
        }
        .upload-icon { font-size: 3rem; margin-bottom: 1rem; display: block; }
        
        /* --- æ§åˆ¶æŒ‰éˆ• --- */
        .controls { display: flex; gap: 15px; justify-content: center; flex-wrap: wrap; margin-bottom: 20px; }
        
        button {
            padding: 12px 28px; border: none; border-radius: 12px; cursor: pointer; 
            color: white; font-weight: 600; font-size: 1rem; 
            display: flex; align-items: center; gap: 8px;
            transition: all 0.2s ease;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        button:hover:not(:disabled) { transform: translateY(-2px); box-shadow: 0 10px 15px -3px rgba(0,0,0,0.15); filter: brightness(1.05); }
        button:active:not(:disabled) { transform: translateY(0); }
        button:disabled { background: #cbd5e1; color: #94a3b8; cursor: not-allowed; box-shadow: none; }

        .btn-analyze { background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%); }
        .btn-excel { background: linear-gradient(135deg, #10b981 0%, #059669 100%); display: none; }
        .btn-zip { background: linear-gradient(135deg, #8b5cf6 0%, #7c3aed 100%); display: none; }

        /* --- é€²åº¦æ¢èˆ‡ç‹€æ…‹ --- */
        .status-container { margin-bottom: 40px; text-align: center; display: none; }
        .progress-wrapper {
            background: #e2e8f0; border-radius: 10px; height: 12px; width: 100%; max-width: 600px;
            margin: 15px auto; overflow: hidden; position: relative;
        }
        .progress-fill {
            background: linear-gradient(90deg, var(--primary), var(--purple));
            height: 100%; width: 0%; border-radius: 10px;
            transition: width 0.3s ease-out;
            position: relative;
        }
        /* å¢åŠ é€²åº¦æ¢çš„æµå…‰æ•ˆæœ */
        .progress-fill::after {
            content: ''; position: absolute; top: 0; left: 0; bottom: 0; right: 0;
            background: linear-gradient(90deg, rgba(255,255,255,0) 0%, rgba(255,255,255,0.4) 50%, rgba(255,255,255,0) 100%);
            transform: translateX(-100%); animation: shimmer 2s infinite;
        }
        @keyframes shimmer { 100% { transform: translateX(100%); } }
        
        #statusText { color: var(--text-sec); font-weight: 500; font-size: 0.95rem; }

        /* --- çµæœåˆ—è¡¨ --- */
        .results-list { display: flex; flex-direction: column; gap: 30px; }

        .group-card {
            background: var(--card-bg); border-radius: 20px; padding: 30px;
            box-shadow: 0 20px 25px -5px rgba(0,0,0,0.05), 0 10px 10px -5px rgba(0,0,0,0.01);
            border: 1px solid #f1f5f9;
            animation: slideIn 0.5s ease-out;
        }
        
        .group-header { 
            display: flex; justify-content: space-between; align-items: center; 
            margin-bottom: 25px; padding-bottom: 20px; border-bottom: 2px solid #f1f5f9; 
        }
        .group-title { font-weight: 800; font-size: 1.5rem; color: #0f172a; display: flex; align-items: center; gap: 10px;}
        .group-badge { 
            background: #eff6ff; color: var(--primary); padding: 6px 16px; 
            border-radius: 99px; font-weight: 700; font-size: 0.9rem; letter-spacing: 0.5px;
        }

        .game-row {
            background: #f8fafc; border: 1px solid #e2e8f0; border-radius: 16px;
            padding: 20px; margin-bottom: 20px; position: relative;
        }
        .game-label {
            position: absolute; top: -12px; left: 20px;
            background: var(--primary); color: white; padding: 4px 12px;
            border-radius: 6px; font-weight: 600; font-size: 0.85rem;
            box-shadow: 0 4px 6px rgba(59, 130, 246, 0.3);
        }
        
        /* æ™‚é–“è»¸ */
        .timeline-container {
            display: flex; align-items: flex-start; gap: 15px; 
            overflow-x: auto; padding: 25px 5px 10px 5px; /* ä¸Šæ–¹ç•™ç©ºçµ¦æ¨™ç±¤ */
        }
        .timeline-container::-webkit-scrollbar { height: 8px; }
        .timeline-container::-webkit-scrollbar-track { background: transparent; }
        .timeline-container::-webkit-scrollbar-thumb { background: #cbd5e1; border-radius: 10px; }

        .step-item {
            flex: 0 0 auto; display: flex; flex-direction: column; align-items: center;
            width: 120px; 
        }
        
        .step-img {
            width: 100%; height: 120px; object-fit: contain; 
            border: 2px solid #e2e8f0; border-radius: 10px; background: white;
            transition: all 0.2s; cursor: zoom-in;
        }
        .step-img:hover { 
            transform: scale(1.08); border-color: var(--primary); 
            box-shadow: 0 10px 15px -3px rgba(0,0,0,0.1); 
        }

        .step-label {
            margin-top: 8px; font-size: 0.85rem; font-weight: 600; 
            color: var(--text-sec); 
        }

        .arrow-separator {
            flex: 0 0 auto; display: flex; align-items: center; height: 120px;
            color: #cbd5e1; font-size: 1.5rem; 
        }

        /* ç‡ˆç®±æ•ˆæœ */
        .modal {
            display: none; position: fixed; z-index: 999; left: 0; top: 0; width: 100%; height: 100%;
            background: rgba(15, 23, 42, 0.95); backdrop-filter: blur(5px);
            align-items: center; justify-content: center; flex-direction: column;
            animation: fadeIn 0.2s;
        }
        .modal img { max-width: 90%; max-height: 80vh; border-radius: 12px; box-shadow: 0 25px 50px -12px rgba(0,0,0,0.5); }
        .modal-caption { color: white; margin-top: 20px; font-size: 1.1rem; background: rgba(255,255,255,0.1); padding: 8px 20px; border-radius: 30px;}
        .modal-close { position: absolute; top: 30px; right: 40px; color: white; font-size: 40px; cursor: pointer; transition: 0.2s; }
        .modal-close:hover { transform: scale(1.1); color: var(--primary); }

        @keyframes slideIn { from { opacity: 0; transform: translateY(20px); } to { opacity: 1; transform: translateY(0); } }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
    </style>
</head>
<body>

<div class="container">
    <header>
        <h1>AI è³½å±€æ¼”è®Šåˆ†æå™¨</h1>
        <p class="desc">æ™ºæ…§åˆ†é¡ç­–ç•¥æ¨¡å¼ãƒ»æ”¯æ´å¤šå±¤çµæ§‹åŒ¯å‡º</p>
    </header>

    <div class="upload-area" id="dropZone">
        <span class="upload-icon">ğŸ“‚</span>
        <h3>æ‹–æ›³åœ–ç‰‡æˆ–é»æ“Šä¸Šå‚³</h3>
        <p style="color: #94a3b8; margin-top: 10px;">è«‹é¸å–æ‰€æœ‰ Game_XXX_Turn_YYY æ ¼å¼çš„åœ–ç‰‡</p>
        <input type="file" id="fileInput" multiple accept="image/*" style="display: none;">
    </div>

    <div class="controls">
        <button id="analyzeBtn" class="btn-analyze" disabled>ğŸš€ é–‹å§‹åˆ†æ</button>
        <button id="downloadExcelBtn" class="btn-excel">ğŸ“Š ä¸‹è¼‰å ±è¡¨ (Excel)</button>
        <button id="downloadZipBtn" class="btn-zip">ğŸ—‚ï¸ ä¸‹è¼‰åˆ†é¡åœ–æª” (ZIP)</button>
    </div>
    
    <div class="status-container" id="statusContainer">
        <div class="progress-wrapper">
            <div class="progress-fill" id="progressBar"></div>
        </div>
        <div id="statusText">æº–å‚™å°±ç·’</div>
    </div>

    <div id="resultsList" class="results-list"></div>
</div>

<div id="imgModal" class="modal" onclick="if(event.target===this)this.style.display='none'">
    <span class="modal-close" onclick="document.getElementById('imgModal').style.display='none'">&times;</span>
    <img id="modalImg">
    <div id="modalCaption" class="modal-caption"></div>
</div>

<script>
    const dropZone = document.getElementById('dropZone');
    const fileInput = document.getElementById('fileInput');
    const analyzeBtn = document.getElementById('analyzeBtn');
    const downloadExcelBtn = document.getElementById('downloadExcelBtn');
    const downloadZipBtn = document.getElementById('downloadZipBtn');
    const statusContainer = document.getElementById('statusContainer');
    const statusText = document.getElementById('statusText');
    const progressBar = document.getElementById('progressBar');
    const resultsList = document.getElementById('resultsList');
    const modal = document.getElementById('imgModal');
    const modalImg = document.getElementById('modalImg');
    const modalCaption = document.getElementById('modalCaption');

    let uploadedFiles = [];
    let clusteredGroups = []; 
    let gameData = {}; 
    const IMG_SIZE = 150;
    const ANGLES = [0, 60, 120, 180, 240, 300];

    // --- æª”æ¡ˆè™•ç† ---
    dropZone.addEventListener('click', () => fileInput.click());
    dropZone.addEventListener('dragover', (e) => { e.preventDefault(); dropZone.style.borderStyle = 'solid'; dropZone.style.borderColor = 'var(--primary)'; dropZone.style.background = '#eff6ff'; });
    dropZone.addEventListener('dragleave', (e) => { e.preventDefault(); dropZone.style.borderStyle = 'dashed'; dropZone.style.borderColor = '#cbd5e1'; dropZone.style.background = '#ffffff'; });
    dropZone.addEventListener('drop', (e) => { 
        e.preventDefault(); 
        dropZone.style.borderStyle = 'dashed'; dropZone.style.borderColor = '#cbd5e1'; dropZone.style.background = '#ffffff';
        handleFiles(e.dataTransfer.files); 
    });
    fileInput.addEventListener('change', (e) => handleFiles(e.target.files));

    function handleFiles(files) {
        const imgs = Array.from(files).filter(f => f.type.startsWith('image/'));
        if (!imgs.length) return;
        uploadedFiles = [...uploadedFiles, ...imgs];
        
        statusContainer.style.display = 'block';
        updateProgress(0, `å·²è¼‰å…¥ ${uploadedFiles.length} å¼µåœ–ç‰‡ï¼Œæº–å‚™åˆ†æ`);
        
        analyzeBtn.disabled = false;
        resultsList.innerHTML = '';
        downloadExcelBtn.style.display = 'none';
        downloadZipBtn.style.display = 'none';
    }

    // --- æ›´æ–°é€²åº¦æ¢ helper ---
    function updateProgress(percent, text) {
        progressBar.style.width = `${percent}%`;
        if(text) statusText.textContent = text;
    }

    // --- åˆ†ææµç¨‹ ---
    analyzeBtn.addEventListener('click', async () => {
        analyzeBtn.disabled = true;
        downloadExcelBtn.style.display = 'none';
        downloadZipBtn.style.display = 'none';
        resultsList.innerHTML = '';
        
        // 1. æ•´ç†è³‡æ–™
        updateProgress(5, "æ­£åœ¨æ•´ç†æª”æ¡ˆç´¢å¼•...");
        gameData = {};
        uploadedFiles.forEach(file => {
            const match = file.name.match(/Game_(\d+)_Turn_(\d+)/i);
            if (match) {
                const gId = match[1];
                const tId = parseInt(match[2]);
                if (!gameData[gId]) gameData[gId] = {};
                gameData[gId][tId] = file;
            }
        });

        const gameIds = Object.keys(gameData).sort();
        if (gameIds.length === 0) {
            alert("æ‰¾ä¸åˆ°ç¬¦åˆæ ¼å¼çš„åœ–ç‰‡");
            analyzeBtn.disabled = false;
            updateProgress(0, "éŒ¯èª¤ï¼šç„¡æœ‰æ•ˆåœ–ç‰‡");
            return;
        }

        // 2. è¨ˆç®—æŒ‡ç´‹ (åŠ ä¸Šé€²åº¦æ¢é‚è¼¯)
        const gameSignatures = {};
        const totalGames = gameIds.length;
        
        for (let i = 0; i < totalGames; i++) {
            const gId = gameIds[i];
            
            // è¨ˆç®—é€²åº¦: 5% ~ 85% æ˜¯è™•ç†åœ–ç‰‡çš„æ™‚é–“
            const progress = 5 + Math.round((i / totalGames) * 80);
            updateProgress(progress, `æ­£åœ¨åˆ†æ Game ${gId} çš„ç­–ç•¥ç‰¹å¾µ... (${i+1}/${totalGames})`);

            // è®“ UI æœ‰æ™‚é–“æ¸²æŸ“æ›´æ–°
            await new Promise(r => setTimeout(r, 0)); 

            const turns = Object.keys(gameData[gId]).map(Number).sort((a,b)=>a-b);
            const signature = [];
            for (let t of turns) {
                const img = await loadImage(gameData[gId][t]);
                const hash = await getRotatedHash(img);
                signature.push({ turn: t, hash: hash });
            }
            gameSignatures[gId] = signature;
        }

        // 3. åˆ†ç¾¤
        updateProgress(90, "æ­£åœ¨é€²è¡Œ AI ç­–ç•¥æ­¸é¡...");
        await new Promise(r => setTimeout(r, 100)); // æ¨¡æ“¬é‹ç®—å»¶é²æ„Ÿ
        clusteredGroups = performClustering(gameIds, gameSignatures);

        // 4. æ¸²æŸ“çµæœ
        updateProgress(95, "æ­£åœ¨ç”¢ç”Ÿè¦–è¦ºåŒ–å ±è¡¨...");
        renderExpandedGroups(clusteredGroups);
        
        updateProgress(100, `åˆ†æå®Œæˆï¼å…±ç™¼ç¾ ${clusteredGroups.length} ç¨®ç­–ç•¥æ¨¡å¼`);
        analyzeBtn.disabled = false;
        downloadExcelBtn.style.display = 'flex';
        downloadZipBtn.style.display = 'flex';
    });

    // --- ä¸‹è¼‰ Excel ---
    downloadExcelBtn.addEventListener('click', () => {
        const excelData = [];
        clusteredGroups.forEach((group, index) => {
            const patternName = `Pattern ${index + 1}`;
            group.members.forEach(gameId => {
                excelData.push({
                    "ç­–ç•¥ç¾¤çµ„": patternName,
                    "è³½å±€ ID": `Game ${gameId}`,
                    "åŒçµ„æˆå“¡æ•¸": group.members.length,
                    "ä»£è¡¨è³½å±€": group.repId === gameId ? "æ˜¯" : ""
                });
            });
        });
        const wb = XLSX.utils.book_new();
        const ws = XLSX.utils.json_to_sheet(excelData);
        ws['!cols'] = [{wch: 15}, {wch: 15}, {wch: 12}, {wch: 10}];
        XLSX.utils.book_append_sheet(wb, ws, "åˆ†é¡çµæœ");
        XLSX.writeFile(wb, `Game_Analysis_Report_${new Date().toISOString().slice(0,10)}.xlsx`);
    });

    // --- ä¸‹è¼‰ ZIP (å·¢ç‹€çµæ§‹) ---
    downloadZipBtn.addEventListener('click', async () => {
        downloadZipBtn.disabled = true;
        const originalText = downloadZipBtn.innerText;
        downloadZipBtn.innerText = "â³ æ‰“åŒ…ä¸­...";
        
        updateProgress(0, "æ­£åœ¨æº–å‚™ ZIP æ‰“åŒ…...");
        const zip = new JSZip();
        
        // ç‚ºäº†é¡¯ç¤ºé€²åº¦ï¼Œæˆ‘å€‘å°‡åŒæ­¥è¿´åœˆæ”¹ç‚º async
        const totalGroups = clusteredGroups.length;
        
        for (let i = 0; i < totalGroups; i++) {
            const group = clusteredGroups[i];
            const patternFolderName = `Pattern_${i + 1}_(Count_${group.members.length})`;
            const patternFolder = zip.folder(patternFolderName);
            
            group.members.forEach(gameId => {
                if(gameData[gameId]) {
                    const gameFolderName = `Game_${gameId}`;
                    const gameFolder = patternFolder.folder(gameFolderName);
                    Object.values(gameData[gameId]).forEach(file => {
                        gameFolder.file(file.name, file);
                    });
                }
            });

            // æ›´æ–°æ‰“åŒ…é€²åº¦
            const percent = Math.round(((i + 1) / totalGroups) * 100);
            updateProgress(percent, `æ­£åœ¨å£“ç¸® Pattern ${i+1}...`);
            await new Promise(r => setTimeout(r, 0));
        }

        try {
            updateProgress(100, "æ­£åœ¨ç”¢ç”Ÿ ZIP æª”æ¡ˆ...");
            const content = await zip.generateAsync({type: "blob"});
            saveAs(content, `Nested_Classified_Games_${new Date().toISOString().slice(0,10)}.zip`);
            updateProgress(100, "ZIP ä¸‹è¼‰å®Œæˆï¼");
        } catch (err) {
            console.error(err);
            statusText.textContent = "ZIP æ‰“åŒ…å¤±æ•—";
        } finally {
            downloadZipBtn.disabled = false;
            downloadZipBtn.innerText = originalText;
        }
    });

    // --- æ¼”ç®—æ³• ---
    function performClustering(gameIds, signatures) {
        const groups = [];
        const visited = new Set();
        const THRESHOLD = 5;

        for (let i = 0; i < gameIds.length; i++) {
            const currentId = gameIds[i];
            if (visited.has(currentId)) continue;
            const newGroup = { repId: currentId, members: [currentId] };
            visited.add(currentId);

            for (let j = i + 1; j < gameIds.length; j++) {
                const targetId = gameIds[j];
                if (visited.has(targetId)) continue;
                if (isStrategySimilar(signatures[currentId], signatures[targetId], THRESHOLD)) {
                    newGroup.members.push(targetId);
                    visited.add(targetId);
                }
            }
            groups.push(newGroup);
        }
        return groups.sort((a,b) => b.members.length - a.members.length);
    }

    function isStrategySimilar(sigA, sigB, threshold) {
        const len = Math.min(sigA.length, sigB.length);
        if (len === 0) return false;
        for (let k = 0; k < len; k++) {
            if (sigA[k].turn !== sigB[k].turn) continue;
            if (hammingDist(sigA[k].hash, sigB[k].hash) > threshold) return false;
        }
        return true;
    }

    // --- æ¸²æŸ“ ---
    function renderExpandedGroups(groups) {
        resultsList.innerHTML = '';
        groups.forEach((group, idx) => {
            const groupCard = document.createElement('div');
            groupCard.className = 'group-card';
            
            groupCard.innerHTML = `
                <div class="group-header">
                    <div class="group-title">
                        <span>ğŸ§© ç­–ç•¥æ¨¡å¼ ${idx + 1}</span>
                    </div>
                    <span class="group-badge">åŒ…å« ${group.members.length} å±€</span>
                </div>
            `;
            
            group.members.forEach(gameId => {
                const turns = Object.keys(gameData[gameId]).map(Number).sort((a,b)=>a-b);
                let timelineHtml = '<div class="timeline-container">';
                turns.forEach((turn, tIdx) => {
                    const imgUrl = URL.createObjectURL(gameData[gameId][turn]);
                    if (tIdx > 0) timelineHtml += `<div class="arrow-separator">â†’</div>`;
                    timelineHtml += `
                        <div class="step-item">
                            <img src="${imgUrl}" class="step-img" 
                                 onclick="showModal('${imgUrl}', 'Game ${gameId} - Turn ${turn}')">
                            <div class="step-label">Turn ${turn}</div>
                        </div>
                    `;
                });
                timelineHtml += '</div>';

                const rowDiv = document.createElement('div');
                rowDiv.className = 'game-row';
                rowDiv.innerHTML = `
                    <div class="game-label">Game ${gameId}</div>
                    ${timelineHtml}
                `;
                groupCard.appendChild(rowDiv);
            });

            resultsList.appendChild(groupCard);
        });
    }

    function showModal(src, text) {
        modal.style.display = 'flex';
        modalImg.src = src;
        modalCaption.textContent = text;
    }

    // --- å½±åƒè™•ç†å‡½å¼ ---
    function loadImage(file) {
        return new Promise(resolve => {
            const img = new Image();
            img.onload = () => resolve(img);
            img.src = URL.createObjectURL(file);
        });
    }
    function getRotatedHash(img) {
        const canvas = preprocessImage(img);
        let minHash = null;
        for (let angle of ANGLES) {
            const rotCanvas = rotateCanvas(canvas, angle);
            const hash = calculateHash(rotCanvas);
            if (minHash === null || hash < minHash) minHash = hash;
        }
        return minHash;
    }
    function preprocessImage(img) {
        const size = IMG_SIZE;
        const cvs = document.createElement('canvas');
        cvs.width = size; cvs.height = size;
        const ctx = cvs.getContext('2d');
        ctx.fillStyle = '#fff'; ctx.fillRect(0,0,size,size);
        const scale = Math.min(size/img.naturalWidth, size/img.naturalHeight) * 0.9;
        const w = img.naturalWidth * scale;
        const h = img.naturalHeight * scale;
        ctx.drawImage(img, (size-w)/2, (size-h)/2, w, h);
        return cvs;
    }
    function rotateCanvas(source, angle) {
        if (angle === 0) return source;
        const cvs = document.createElement('canvas');
        cvs.width = source.width; cvs.height = source.height;
        const ctx = cvs.getContext('2d');
        ctx.fillStyle = '#fff'; ctx.fillRect(0,0,cvs.width,cvs.height);
        ctx.translate(cvs.width/2, cvs.height/2);
        ctx.rotate(angle * Math.PI / 180);
        ctx.drawImage(source, -cvs.width/2, -cvs.height/2);
        return cvs;
    }
    function calculateHash(canvas) {
        const size = 16; 
        const cvs = document.createElement('canvas');
        cvs.width = size; cvs.height = size;
        const ctx = cvs.getContext('2d');
        ctx.drawImage(canvas, 0, 0, size, size);
        const data = ctx.getImageData(0, 0, size, size).data;
        let hash = "";
        for(let i=0; i<data.length; i+=4) {
            const r=data[i], g=data[i+1], b=data[i+2];
            if ((r+g+b)/3 > 220) hash += "0"; 
            else if (r > g+30 && r > b+30) hash += "1";
            else if (b > r+30 && b > g+30) hash += "2";
            else hash += "3";
        }
        return hash;
    }
    function hammingDist(s1, s2) {
        let d = 0;
        for(let i=0; i<s1.length; i++) if(s1[i]!==s2[i]) d++;
        return d;
    }
</script>
</body>
</html>
