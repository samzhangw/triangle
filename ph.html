<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI è³½å±€æ¼”è®Šåˆ†æå™¨ (ç´…è—é–å®šç‰ˆ)</title>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@400;500;700&family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    
    <script src="https://cdn.sheetjs.com/xlsx-0.19.3/package/dist/xlsx.full.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>

    <style>
        :root { 
            --primary: #6366f1; --primary-hover: #4f46e5; --secondary: #ec4899;
            --bg-gradient: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            --card-bg: rgba(255, 255, 255, 0.9); --glass-border: 1px solid rgba(255, 255, 255, 0.5);
            --shadow: 0 10px 30px -5px rgba(0, 0, 0, 0.1); --text-main: #1e293b; --text-light: #64748b;
        }
        * { box-sizing: border-box; }
        body { font-family: 'Inter', 'Noto Sans TC', sans-serif; background: var(--bg-gradient); min-height: 100vh; padding: 40px 20px 120px 20px; color: var(--text-main); line-height: 1.6; }
        .container { max-width: 1200px; margin: 0 auto; }

        header { text-align: center; margin-bottom: 30px; position: relative; background: var(--card-bg); padding: 30px; border-radius: 24px; box-shadow: var(--shadow); border: var(--glass-border); backdrop-filter: blur(10px); }
        h1 { font-size: 2.2rem; margin: 0 0 10px 0; font-weight: 800; color: var(--text-main); }
        .gradient-text { background: linear-gradient(to right, var(--primary), var(--secondary)); -webkit-background-clip: text; -webkit-text-fill-color: transparent; }
        .pro-badge { font-size: 0.5em; vertical-align: middle; background: #ef4444; color: white; padding: 4px 8px; border-radius: 6px; -webkit-text-fill-color: white; }
        .desc { color: var(--text-light); font-size: 1rem; }
        .btn-help { position: absolute; top: 20px; right: 20px; background: #f1f5f9; color: var(--text-main); border: none; width: 40px; height: 40px; border-radius: 50%; font-size: 1.2rem; cursor: pointer; transition: all 0.2s; display: flex; align-items: center; justify-content: center; }
        .btn-help:hover { background: var(--primary); color: white; transform: rotate(15deg); }

        .dashboard { background: var(--card-bg); padding: 25px; border-radius: 20px; box-shadow: var(--shadow); border: var(--glass-border); margin-bottom: 30px; display: flex; flex-wrap: wrap; gap: 20px; align-items: center; justify-content: space-between; }
        .setting-group { display: flex; align-items: center; gap: 15px; flex: 1; min-width: 300px; }
        .setting-label { font-weight: 700; color: var(--text-main); display: flex; align-items: center; gap: 6px; }
        input[type=range] { flex: 1; height: 6px; border-radius: 5px; background: #e2e8f0; outline: none; -webkit-appearance: none; }
        input[type=range]::-webkit-slider-thumb { -webkit-appearance: none; width: 20px; height: 20px; border-radius: 50%; background: var(--primary); cursor: pointer; border: 2px solid white; box-shadow: 0 2px 5px rgba(0,0,0,0.2); transition: transform 0.1s; }
        input[type=range]::-webkit-slider-thumb:hover { transform: scale(1.2); }
        .slider-value { background: var(--primary); color: white; padding: 2px 10px; border-radius: 10px; font-size: 0.85rem; font-weight: bold; min-width: 35px; text-align: center; }
        .action-group { display: flex; gap: 10px; }
        .btn { padding: 10px 20px; border: none; border-radius: 12px; cursor: pointer; font-weight: 600; font-size: 0.95rem; display: inline-flex; align-items: center; gap: 8px; transition: all 0.2s; }
        .btn:hover:not(:disabled) { transform: translateY(-2px); box-shadow: 0 5px 15px rgba(0,0,0,0.1); }
        .btn:disabled { opacity: 0.6; cursor: not-allowed; filter: grayscale(1); }
        .btn-primary { background: var(--primary); color: white; }
        .btn-recalc { background: #f59e0b; color: white; display: none; }
        .btn-excel { background: #10b981; color: white; display: none; }
        .btn-zip { background: #8b5cf6; color: white; display: none; }

        .upload-area { background: rgba(255,255,255,0.6); border: 2px dashed #cbd5e1; border-radius: 20px; padding: 2.5rem; text-align: center; cursor: pointer; transition: all 0.3s ease; margin-bottom: 30px; }
        .upload-area:hover { border-color: var(--primary); background: #eef2ff; transform: scale(1.01); }
        .upload-icon { font-size: 2.5rem; margin-bottom: 0.5rem; opacity: 0.8; }

        .status-container { margin-bottom: 30px; display: none; }
        .progress-track { background: #e2e8f0; border-radius: 10px; height: 10px; overflow: hidden; position: relative; }
        .progress-fill { background: linear-gradient(90deg, var(--primary), var(--secondary)); height: 100%; width: 0%; border-radius: 10px; transition: width 0.3s ease-out; position: relative; }
        .status-text { margin-top: 8px; text-align: right; font-size: 0.85rem; color: var(--text-light); font-weight: 500; }
        
        .result-summary { margin-bottom: 20px; font-size: 1.2rem; font-weight: 700; color: var(--text-main); display: flex; align-items: center; gap: 10px; background: rgba(255,255,255,0.5); padding: 10px 20px; border-radius: 12px; border: 1px solid #e2e8f0; }
        .result-summary span { color: var(--primary); font-size: 1.4rem; }

        .results-list { display: flex; flex-direction: column; gap: 25px; }
        .group-card { background: var(--card-bg); border-radius: 20px; padding: 25px; box-shadow: var(--shadow); border: var(--glass-border); transition: all 0.2s; }
        .group-card.drag-over { border: 2px solid var(--secondary); background: #fff5f9; transform: scale(1.005); }
        .group-header { display: flex; flex-direction: column; gap: 5px; margin-bottom: 20px; padding-bottom: 15px; border-bottom: 1px solid #e2e8f0; }
        .group-title-row { display: flex; justify-content: space-between; align-items: center; }
        .group-title { font-size: 1.25rem; font-weight: 800; color: var(--text-main); display: flex; align-items: center; gap: 8px;}
        .group-badge { background: #e0e7ff; color: var(--primary); padding: 4px 12px; border-radius: 20px; font-size: 0.8rem; font-weight: 700; }
        .group-reason { font-size: 0.9rem; color: #64748b; background: #f8fafc; padding: 8px 12px; border-radius: 8px; border-left: 4px solid var(--secondary); margin-top: 5px; display: flex; align-items: center; gap: 6px; }

        .game-row { background: #fff; border: 1px solid #e2e8f0; border-radius: 16px; padding: 15px; margin-bottom: 15px; position: relative; transition: all 0.2s; cursor: default; display: flex; flex-direction: column; }
        .game-row:hover { border-color: var(--primary); box-shadow: 0 4px 12px rgba(0,0,0,0.05); }
        .game-row.dragging { opacity: 0.4; transform: scale(0.98); border: 2px dashed #94a3b8; }
        .game-row.selected { border: 2px solid var(--secondary); background: #fff0f5; }
        .game-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; }
        .game-id-tag { background: var(--text-main); color: white; padding: 4px 10px; border-radius: 6px; font-size: 0.85rem; font-weight: 600; display: flex; align-items: center; gap: 8px; }
        .drag-handle { cursor: grab; opacity: 0.7; font-size: 1.2rem; padding: 0 4px; transition: 0.2s; color: rgba(255,255,255,0.8); }
        .drag-handle:hover { opacity: 1; transform: scale(1.2); } .drag-handle:active { cursor: grabbing; }
        .btn-mini { background: white; border: 1px solid #cbd5e1; color: var(--text-light); padding: 4px 10px; border-radius: 6px; font-size: 0.8rem; cursor: pointer; transition: 0.2s; }
        .btn-mini:hover { border-color: var(--secondary); color: var(--secondary); }
        .btn-mini.active { background: var(--secondary); color: white; border-color: var(--secondary); }

        .timeline { display: flex; gap: 10px; overflow-x: auto; padding-bottom: 5px; scrollbar-width: thin; }
        .step { flex: 0 0 auto; text-align: center; width: 100px; }
        .step img { width: 100%; height: 100px; object-fit: contain; border: 1px solid #e2e8f0; border-radius: 8px; background: white; cursor: zoom-in; transition: transform 0.2s; }
        .step img:hover { transform: scale(1.1); border-color: var(--primary); box-shadow: 0 5px 15px rgba(0,0,0,0.1); z-index: 10; position: relative;}

        .btn-add-group { width: 100%; padding: 15px; border: 2px dashed #cbd5e1; border-radius: 16px; background: rgba(255,255,255,0.5); color: #64748b; font-weight: 600; cursor: pointer; transition: 0.2s; margin-top: 10px; display: none; text-align: center; }
        .btn-add-group:hover { border-color: var(--primary); color: var(--primary); background: #eef2ff; }

        .compare-bar { position: fixed; bottom: 30px; left: 50%; transform: translateX(-50%) translateY(150%); background: #1e293b; color: white; padding: 12px 25px; border-radius: 50px; box-shadow: 0 20px 40px rgba(0,0,0,0.3); display: flex; align-items: center; gap: 20px; z-index: 100; transition: transform 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275); }
        .compare-bar.show { transform: translateX(-50%) translateY(0); }
        .btn-compare-go { background: var(--secondary); border: none; padding: 6px 18px; border-radius: 20px; color: white; cursor: pointer; font-weight: bold;}
        .btn-close-bar { background: transparent; border: none; color: #94a3b8; font-size: 1.2rem; cursor: pointer; }

        .modal-overlay { display: none; position: fixed; z-index: 2000; left: 0; top: 0; width: 100%; height: 100%; background: rgba(15, 23, 42, 0.8); backdrop-filter: blur(8px); align-items: center; justify-content: center; }
        .modal-content { background: white; width: 95%; max-width: 1000px; max-height: 90vh; border-radius: 20px; padding: 30px; overflow-y: auto; position: relative; box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25); animation: slideUp 0.3s ease-out; }
        @keyframes slideUp { from { opacity: 0; transform: translateY(20px); } to { opacity: 1; transform: translateY(0); } }

        /* Diff Toolbar */
        .diff-toolbar { display: flex; gap: 10px; margin-bottom: 20px; padding: 15px; background: #f1f5f9; border-radius: 12px; align-items: center; flex-wrap: wrap;}
        .diff-btn { background: white; border: 1px solid #cbd5e1; padding: 8px 15px; border-radius: 8px; cursor: pointer; font-weight: 600; display: flex; align-items: center; gap: 5px; transition:0.2s;}
        .diff-btn:hover { background: var(--primary); color: white; border-color: var(--primary); }
        .diff-btn.active { background: var(--secondary); color: white; border-color: var(--secondary); }
        
        .angle-input { width: 60px; padding: 6px; border: 1px solid #cbd5e1; border-radius: 6px; text-align: center; font-weight: bold; color: var(--text-main); }
        .angle-input:focus { outline: none; border-color: var(--primary); }
        
        /* Onion Skin Controls */
        .onion-controls { display: flex; align-items: center; gap: 10px; margin-left: 15px; padding-left: 15px; border-left: 2px solid #cbd5e1; }
        .onion-slider-group { display: flex; align-items: center; gap: 8px; font-size: 0.9rem; opacity: 0.5; pointer-events: none; transition: opacity 0.2s; }
        .onion-slider-group.active { opacity: 1; pointer-events: auto; }

        .diff-grid { display: grid; grid-template-columns: 80px 1fr 1fr 1fr; gap: 15px; border-bottom: 1px solid #eee; padding: 15px 0; align-items: center; }
        .diff-header { font-weight: bold; color: var(--text-light); text-align: center; background: #f8fafc; padding: 10px; border-radius: 8px; }
        .diff-img-wrap { text-align: center; position: relative; }
        .diff-img-wrap img { width: 100%; border-radius: 6px; border: 1px solid #eee; display: block; }
        .diff-mark { border: 2px solid var(--secondary); box-shadow: 0 0 10px rgba(236, 72, 153, 0.3); }

        /* Onion Skin Overlay Styles */
        .onion-container { position: relative; width: 100%; display: block; border-radius: 6px; overflow: hidden; border: 1px solid #cbd5e1; }
        .onion-layer-base { width: 100%; display: block; }
        .onion-layer-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 10; opacity: 0.5; transition: opacity 0.1s linear; }
    </style>
</head>
<body>

<div class="container">
    <header>
        <button class="btn-help" onclick="showHelp()" title="ä½¿ç”¨èªªæ˜">?</button>
        <h1>
            <span class="gradient-text">AI è³½å±€æ¼”è®Šåˆ†æå™¨</span> 
            <span class="pro-badge">Red/Blue High Accuracy</span>
        </h1>
        <p class="desc">å°ˆæ³¨è­˜åˆ¥ã€Œç´…ã€è—ã€è³½å±€ç­–ç•¥è®ŠåŒ–ï¼Œå°å…¥ HSV ç²¾æº–è‰²å½©åˆ¤å®šèˆ‡æŠ—æ‰‹éœ‡å®¹éŒ¯ã€‚</p>
    </header>

    <div id="helpModal" class="modal-overlay" onclick="if(event.target===this)closeModal('helpModal')">
        <div class="modal-content" style="max-width: 600px;">
             <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:20px;">
                <h2 style="margin:0;">ğŸ“– ä½¿ç”¨æŒ‡å—</h2>
                <button onclick="closeModal('helpModal')" style="border:none; background:none; font-size:1.5rem; cursor:pointer;">&times;</button>
            </div>
            <p>1. <b>ä¸Šå‚³</b>ï¼šæ‹–æ›³ Game_X_Turn_Y åœ–ç‰‡ã€‚</p>
            <p>2. <b>åˆ†æ</b>ï¼šç³»çµ±æœƒè‡ªå‹•é€²è¡Œç­–ç•¥æ­¸é¡ (ä½¿ç”¨ HSV å¢å¼·æº–ç¢ºåº¦)ã€‚</p>
            <p>3. <b>æ¯”å°</b>ï¼šé¸å–å…©å±€é€²è¡Œæ¯”å°ã€‚</p>
            <p>4. <b>æ´‹è”¥çš®æ¨¡å¼</b>ï¼šåœ¨æ¯”å°è¦–çª—é–‹å•Ÿ ğŸ§… æŒ‰éˆ•ï¼Œå³å¯å°‡å…©å¼µåœ–ç–ŠåŠ é¡¯ç¤ºã€‚</p>
        </div>
    </div>

    <div class="dashboard">
        <div class="setting-group">
            <div class="setting-label"><span>ğŸ¤– AI åš´æ ¼åº¦</span><span id="thresholdValue" class="slider-value">5</span></div>
            <input type="range" id="thresholdRange" min="0" max="15" value="5" step="1">
        </div>
        <div class="action-group">
            <button id="analyzeBtn" class="btn btn-primary" disabled>ğŸš€ é–‹å§‹åˆ†æ</button>
            <button id="recalcBtn" class="btn btn-recalc">ğŸ”„ ä¾è¨­å®šé‡ç®—</button>
            <button id="downloadExcelBtn" class="btn btn-excel">ğŸ“Š ä¸‹è¼‰ Excel</button>
            <button id="downloadZipBtn" class="btn btn-zip">ğŸ’¾ ä¸‹è¼‰ ZIP</button>
        </div>
    </div>

    <div class="upload-area" id="dropZone">
        <span class="upload-icon">ğŸ“‚</span>
        <h3>æ‹–æ›³åœ–ç‰‡æˆ–é»æ“Šé€™è£¡ä¸Šå‚³</h3>
        <input type="file" id="fileInput" multiple accept="image/*" style="display: none;">
    </div>
    
    <div class="status-container" id="statusContainer">
        <div class="progress-track"><div class="progress-fill" id="progressBar"></div></div>
        <div class="status-text" id="statusText">æº–å‚™å°±ç·’</div>
    </div>

    <div id="resultSummary" style="display:none;" class="result-summary"></div>

    <div id="resultsList" class="results-list"></div>
    <button id="addGroupBtn" class="btn-add-group">â• æ–°å¢ä¸€å€‹ç©ºç¾¤çµ„ (å°‡è³½å±€æ‹–æ›³è‡³æ­¤)</button>
</div>

<div id="compareBar" class="compare-bar">
    <span id="compareInfo" style="font-size:0.9rem;">å·²é¸æ“‡ 0/2 å±€</span>
    <button id="startCompareBtn" class="btn-compare-go" disabled>é–‹å§‹æ¯”å°</button>
    <button onclick="clearComparison()" class="btn-close-bar" title="å–æ¶ˆ">âœ•</button>
</div>

<div id="compareModal" class="modal-overlay">
    <div class="modal-content">
        <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:20px; border-bottom:2px solid #f1f5f9; padding-bottom:15px;">
            <h2 id="compareTitle" style="margin:0; font-size:1.5rem;">ç´…è—å·®ç•°æ¯”å° (é«˜ç²¾åº¦)</h2>
            <button onclick="closeModal('compareModal')" style="border:none; background:none; font-size:1.5rem; cursor:pointer;">&times;</button>
        </div>
        
        <div class="diff-toolbar">
            <div style="display:flex; align-items:center; gap:5px;">
                <span>æ¯æ¬¡æ—‹è½‰:</span>
                <input type="number" id="rotateStepInput" value="60" min="1" max="180" class="angle-input">
                <span style="font-size:0.9rem;">åº¦</span>
                <button class="diff-btn" onclick="rotateCompareImage()">âŸ³ æ—‹è½‰</button>
                <button class="diff-btn" onclick="mirrorCompareImage()">â†”ï¸ é¡åƒ</button>
            </div>

            <div class="onion-controls">
                <button id="onionToggleBtn" class="diff-btn" onclick="toggleOnionMode()">ğŸ§… æ´‹è”¥çš®æ¨¡å¼</button>
                <div id="onionSliderGroup" class="onion-slider-group">
                    <span>é€æ˜åº¦</span>
                    <input type="range" id="onionOpacityRange" min="0" max="100" value="50" oninput="updateOnionOpacity(this.value)">
                    <span id="onionOpacityVal">50%</span>
                </div>
            </div>
            
            <div id="diffStatus" style="font-size:0.85rem; color:#64748b; font-weight:normal; margin-left:auto;">(åŸå§‹è¦–è§’)</div>
        </div>

        <div id="compareContent"></div>
    </div>
</div>

<div id="imgModal" class="modal-overlay" onclick="if(event.target===this)closeModal('imgModal')">
    <div style="background:transparent; text-align:center;">
        <img id="modalImg" style="max-width:90%; max-height:80vh; border-radius:12px; box-shadow:0 20px 25px -5px rgba(0,0,0,0.5);">
        <div id="modalCaption" style="color:white; margin-top:15px; font-size:1.1rem; background:rgba(0,0,0,0.5); display:inline-block; padding:5px 15px; border-radius:20px;"></div>
    </div>
</div>

<script>
    const helpModal = document.getElementById('helpModal');
    function showHelp() { helpModal.style.display = 'flex'; }
    function closeModal(id) { document.getElementById(id).style.display = 'none'; }

    const dropZone = document.getElementById('dropZone'), fileInput = document.getElementById('fileInput'), analyzeBtn = document.getElementById('analyzeBtn'), recalcBtn = document.getElementById('recalcBtn');
    const downloadExcelBtn = document.getElementById('downloadExcelBtn'), downloadZipBtn = document.getElementById('downloadZipBtn'), statusContainer = document.getElementById('statusContainer');
    const statusText = document.getElementById('statusText'), progressBar = document.getElementById('progressBar'), resultsList = document.getElementById('resultsList'), addGroupBtn = document.getElementById('addGroupBtn');
    const thresholdRange = document.getElementById('thresholdRange'), thresholdValue = document.getElementById('thresholdValue');
    const resultSummary = document.getElementById('resultSummary');
    const compareBar = document.getElementById('compareBar'), compareInfo = document.getElementById('compareInfo'), startCompareBtn = document.getElementById('startCompareBtn');
    const compareModal = document.getElementById('compareModal'), compareContent = document.getElementById('compareContent'), diffStatus = document.getElementById('diffStatus');
    const modalImg = document.getElementById('modalImg'), modalCaption = document.getElementById('modalCaption');
    const rotateStepInput = document.getElementById('rotateStepInput');
    
    // Onion Skin Elements
    const onionToggleBtn = document.getElementById('onionToggleBtn');
    const onionSliderGroup = document.getElementById('onionSliderGroup');
    const onionOpacityRange = document.getElementById('onionOpacityRange');
    const onionOpacityVal = document.getElementById('onionOpacityVal');

    let uploadedFiles = [], clusteredGroups = [], gameData = {}, gameSignatures = {}, gameIds = [], selectedGames = [];
    const IMG_SIZE = 150, ANGLES = [0, 60, 120, 180, 240, 300];
    let currentCompareRotation = 0;
    let currentCompareMirror = false;
    
    // Onion Skin State
    let isOnionMode = false;
    let currentOnionOpacity = 0.5;

    thresholdRange.addEventListener('input', (e) => thresholdValue.textContent = e.target.value);
    thresholdRange.addEventListener('change', () => { if(gameIds.length > 0) recalcBtn.style.display = 'inline-flex'; });
    dropZone.addEventListener('click', () => fileInput.click());
    dropZone.addEventListener('dragover', (e) => { e.preventDefault(); dropZone.style.borderColor = 'var(--primary)'; dropZone.style.background = '#eef2ff'; });
    dropZone.addEventListener('dragleave', (e) => { e.preventDefault(); dropZone.style.borderColor = '#cbd5e1'; dropZone.style.background = 'rgba(255,255,255,0.6)'; });
    dropZone.addEventListener('drop', (e) => { e.preventDefault(); dropZone.style.borderColor = '#cbd5e1'; dropZone.style.background = 'rgba(255,255,255,0.6)'; handleFiles(e.dataTransfer.files); });
    fileInput.addEventListener('change', (e) => handleFiles(e.target.files));
    addGroupBtn.addEventListener('click', () => { clusteredGroups.push({ repId: null, members: [] }); renderExpandedGroups(clusteredGroups); setTimeout(() => window.scrollTo({ top: document.body.scrollHeight, behavior: 'smooth' }), 100); });

    function handleFiles(files) {
        const imgs = Array.from(files).filter(f => f.type.startsWith('image/'));
        if (!imgs.length) return;
        uploadedFiles = [...uploadedFiles, ...imgs]; statusContainer.style.display = 'block'; updateProgress(0, `å·²è¼‰å…¥ ${uploadedFiles.length} å¼µåœ–ç‰‡`);
        analyzeBtn.disabled = false; recalcBtn.style.display = 'none'; downloadExcelBtn.style.display = 'none'; downloadZipBtn.style.display = 'none'; addGroupBtn.style.display = 'none'; resultsList.innerHTML = '';
        resultSummary.style.display = 'none';
        gameSignatures = {}; gameIds = []; clearComparison();
    }
    function updateProgress(percent, text) { progressBar.style.width = `${percent}%`; if(text) statusText.textContent = text; }
    analyzeBtn.addEventListener('click', async () => await runAnalysis(true));
    recalcBtn.addEventListener('click', async () => await runAnalysis(false));

    async function runAnalysis(fullRun) {
        analyzeBtn.disabled = true; recalcBtn.style.display = 'none'; resultsList.innerHTML = ''; resultSummary.style.display = 'none'; clearComparison();
        if (fullRun) {
            updateProgress(5, "æ­£åœ¨å»ºç«‹ç´¢å¼• (HSV å¢å¼·)..."); gameData = {};
            uploadedFiles.forEach(file => { const match = file.name.match(/Game_(\d+)_Turn_(\d+)/i); if (match) { const gId = match[1], tId = parseInt(match[2]); if (!gameData[gId]) gameData[gId] = {}; gameData[gId][tId] = file; } });
            gameIds = Object.keys(gameData).sort(); if (gameIds.length === 0) { alert("ç„¡æœ‰æ•ˆåœ–ç‰‡"); analyzeBtn.disabled = false; return; }
            for (let i = 0; i < gameIds.length; i++) {
                updateProgress(5 + Math.round((i / gameIds.length) * 80), `åˆ†æ Game ${gameIds[i]}...`); await new Promise(r => setTimeout(r, 0));
                const turns = Object.keys(gameData[gameIds[i]]).map(Number).sort((a,b)=>a-b), signature = [];
                for (let t of turns) { const img = await loadImage(gameData[gameIds[i]][t]), hash = await getRotatedHash(img); signature.push({ turn: t, hash: hash }); }
                gameSignatures[gameIds[i]] = signature;
            }
        }
        updateProgress(90, "AI ç­–ç•¥æ­¸é¡ä¸­..."); clusteredGroups = performClustering(gameIds, gameSignatures, parseInt(thresholdRange.value));
        updateProgress(95, "æ­£åœ¨ç”¢ç”Ÿè¦–è¦ºåŒ–å ±è¡¨..."); renderExpandedGroups(clusteredGroups);
        
        resultSummary.style.display = 'flex';
        resultSummary.innerHTML = `<div>ğŸ“Š åˆ†æå®Œæˆï¼ŒAI è‡ªå‹•è­˜åˆ¥å‡º <span style="font-size:1.5rem; color:var(--primary); font-weight:800; margin:0 5px;">${clusteredGroups.length}</span> ç¨®ç­–ç•¥æµæ´¾</div>`;

        updateProgress(100, `åˆ†æå®Œæˆï¼`); analyzeBtn.disabled = false; downloadExcelBtn.style.display = 'inline-flex'; downloadZipBtn.style.display = 'inline-flex'; addGroupBtn.style.display = 'block';
    }

    let draggedGameId = null, sourceGroupIndex = null;
    function initDragEvents() {
        document.querySelectorAll('.game-row').forEach(row => {
            const handle = row.querySelector('.drag-handle'); row.setAttribute('draggable', 'false');
            handle.addEventListener('mousedown', () => row.setAttribute('draggable', 'true'));
            handle.addEventListener('mouseup', () => row.setAttribute('draggable', 'false'));
            row.addEventListener('dragstart', (e) => { draggedGameId = row.dataset.gameId; sourceGroupIndex = row.closest('.group-card').dataset.index; row.classList.add('dragging'); e.dataTransfer.setData('text/plain', draggedGameId); e.dataTransfer.effectAllowed = "move"; });
            row.addEventListener('dragend', () => { row.classList.remove('dragging'); row.setAttribute('draggable', 'false'); draggedGameId = null; document.querySelectorAll('.group-card').forEach(g => g.classList.remove('drag-over')); });
        });
        document.querySelectorAll('.group-card').forEach(group => {
            group.addEventListener('dragover', (e) => { e.preventDefault(); group.classList.add('drag-over'); e.dataTransfer.dropEffect = "move"; });
            group.addEventListener('dragleave', () => group.classList.remove('drag-over'));
            group.addEventListener('drop', (e) => { e.preventDefault(); group.classList.remove('drag-over'); if (draggedGameId && sourceGroupIndex !== null && sourceGroupIndex !== group.dataset.index) moveGame(draggedGameId, parseInt(sourceGroupIndex), parseInt(group.dataset.index)); });
        });
    }
    function moveGame(gameId, fromIdx, toIdx) { clusteredGroups[fromIdx].members = clusteredGroups[fromIdx].members.filter(id => id !== gameId); clusteredGroups[toIdx].members.push(gameId); clusteredGroups[toIdx].members.sort(); renderExpandedGroups(clusteredGroups); }

    function renderExpandedGroups(groups) {
        resultsList.innerHTML = '';
        groups.forEach((group, idx) => {
            const groupCard = document.createElement('div'); groupCard.className = 'group-card'; groupCard.dataset.index = idx;
            let reasonHtml = '';
            if (group.repId) {
                reasonHtml = `<div class="group-reason">ğŸ” æ­¸é¡åŸå› ï¼šè³½å±€æ¼”è®Šç‰¹å¾µèˆ‡ <b>Game ${group.repId}</b> é«˜åº¦ç›¸ä¼¼ (è¦–è¦ºå·®ç•°æŒ‡æ•¸ < ${thresholdRange.value})</div>`;
            } else {
                reasonHtml = `<div class="group-reason" style="border-left-color:#94a3b8;">ğŸ“‚ è‡ªè¨‚ç¾¤çµ„ (æ‰‹å‹•æ­¸é¡)</div>`;
            }

            groupCard.innerHTML = `
                <div class="group-header">
                    <div class="group-title-row">
                        <div class="group-title"><span>ğŸ§© ç­–ç•¥æ¨¡å¼ ${idx + 1}</span></div>
                        <span class="group-badge">åŒ…å« ${group.members.length} å±€</span>
                    </div>
                    ${reasonHtml}
                </div>`;
            
            if (group.members.length === 0) groupCard.innerHTML += `<div style="text-align:center; color:#94a3b8; padding:30px; border:2px dashed #e2e8f0; border-radius:12px;">( æ­¤ç¾¤çµ„ç‚ºç©ºï¼Œè«‹å°‡åˆ†éŒ¯çš„è³½å±€æ‹–æ›³è‡³æ­¤ )</div>`;
            group.members.forEach(gameId => {
                if(!gameData[gameId]) return;
                const turns = Object.keys(gameData[gameId]).map(Number).sort((a,b)=>a-b);
                let timelineHtml = '<div class="timeline">';
                turns.forEach((turn) => { timelineHtml += `<div class="step"><img src="${URL.createObjectURL(gameData[gameId][turn])}" onclick="showImgModal('${URL.createObjectURL(gameData[gameId][turn])}', 'Game ${gameId} - T${turn}')"><span>T${turn}</span></div>`; });
                timelineHtml += '</div>';
                const rowDiv = document.createElement('div'); rowDiv.className = 'game-row'; rowDiv.dataset.gameId = gameId; if(selectedGames.includes(gameId)) rowDiv.classList.add('selected');
                rowDiv.innerHTML = `<div class="game-header"><div class="game-id-tag"><span class="drag-handle" title="æŒ‰ä½ä»¥æ‹–æ›³">â‹®â‹®</span> Game ${gameId}</div><button class="btn-mini ${selectedGames.includes(gameId)?'active':''}" onclick="toggleCompare('${gameId}', this)">${selectedGames.includes(gameId)?'âœ“ å·²é¸':'âš–ï¸ æ¯”å°'}</button></div>${timelineHtml}`;
                groupCard.appendChild(rowDiv);
            });
            resultsList.appendChild(groupCard);
        });
        initDragEvents();
    }

    window.toggleCompare = function(gameId, btn) {
        if (selectedGames.includes(gameId)) selectedGames = selectedGames.filter(id => id !== gameId);
        else { if (selectedGames.length >= 2) { alert("ä¸€æ¬¡åªèƒ½æ¯”å°å…©å±€"); return; } selectedGames.push(gameId); }
        renderExpandedGroups(clusteredGroups); updateCompareBar();
    };
    function updateCompareBar() {
        if (selectedGames.length > 0) { compareBar.classList.add('show'); compareInfo.textContent = `å·²é¸æ“‡ ${selectedGames.length}/2 å±€`; startCompareBtn.disabled = selectedGames.length !== 2; } else compareBar.classList.remove('show');
    }
    window.clearComparison = function() { selectedGames = []; renderExpandedGroups(clusteredGroups); updateCompareBar(); };

    startCompareBtn.addEventListener('click', () => {
        if (selectedGames.length !== 2) return;
        currentCompareRotation = 0; currentCompareMirror = false; 
        
        isOnionMode = false;
        onionToggleBtn.classList.remove('active');
        onionSliderGroup.classList.remove('active');

        updateDiffStatus();
        compareModal.style.display = 'flex';
        document.getElementById('compareTitle').innerText = `æ¯”å°: Game ${selectedGames[0]} vs ${selectedGames[1]}`;
        renderComparisonResults();
    });

    function updateDiffStatus() {
        let status = [];
        if (currentCompareRotation > 0) status.push(`æ—‹è½‰ ${currentCompareRotation}Â°`);
        if (currentCompareMirror) status.push(`é¡åƒ`);
        diffStatus.textContent = status.length > 0 ? ("(è®Šæ›: " + status.join(" + ") + ")") : "(åŸå§‹è¦–è§’)";
    }

    window.rotateCompareImage = function() {
        const step = parseInt(rotateStepInput.value) || 60;
        currentCompareRotation = (currentCompareRotation + step) % 360;
        updateDiffStatus(); renderComparisonResults();
    };
    window.mirrorCompareImage = function() { currentCompareMirror = !currentCompareMirror; updateDiffStatus(); renderComparisonResults(); };

    // --- Onion Skin Logic ---
    window.toggleOnionMode = function() {
        isOnionMode = !isOnionMode;
        if (isOnionMode) {
            onionToggleBtn.classList.add('active');
            onionSliderGroup.classList.add('active');
        } else {
            onionToggleBtn.classList.remove('active');
            onionSliderGroup.classList.remove('active');
        }
        renderComparisonResults();
    };

    window.updateOnionOpacity = function(val) {
        currentOnionOpacity = val / 100;
        onionOpacityVal.textContent = `${val}%`;
        const overlays = document.querySelectorAll('.onion-layer-overlay');
        overlays.forEach(img => img.style.opacity = currentOnionOpacity);
    };

    async function renderComparisonResults() {
        const gA = selectedGames[0], gB = selectedGames[1];
        compareContent.innerHTML = '<div style="text-align:center; padding:50px; color:#64748b;">æ­£åœ¨é‹ç®—ä¸­...</div>';
        await new Promise(r => setTimeout(r, 20));

        const turnsA = Object.keys(gameData[gA]).map(Number), turnsB = Object.keys(gameData[gB]).map(Number);
        const allTurns = Array.from(new Set([...turnsA, ...turnsB])).sort((a,b)=>a-b);
        
        const middleTitle = isOnionMode ? `ç–Šåœ–æ¨¡å¼ (A+B)` : `Game ${gB} (æª¢è¦–)`;
        let html = `<div class="diff-grid diff-header"><div>å›åˆ</div><div>Game ${gA} (åŸºæº–)</div><div>${middleTitle}</div><div style="color:var(--secondary);">ç­–ç•¥å·®ç•° (ç´…/è—)</div></div>`;

        for (let t of allTurns) {
            const fA = gameData[gA][t], fB = gameData[gB][t];
            const urlA = fA ? URL.createObjectURL(fA) : null;
            let imgA_Html = urlA ? `<img src="${urlA}">` : '<span style="color:#ccc">ç„¡</span>';
            let imgB_Html = '<span style="color:#ccc">ç„¡</span>';
            let diffHtml = '<span style="color:#ccc">-</span>';

            if(fA && fB) {
                try {
                    const imgObjA = await loadImage(fA);
                    const imgObjB = await loadImage(fB);
                    
                    const transformedCanvasB = createTransformedCanvas(imgObjB, currentCompareRotation, currentCompareMirror);
                    const urlB_Transformed = transformedCanvasB.toDataURL();

                    if (isOnionMode) {
                        imgB_Html = `
                            <div class="onion-container">
                                <img src="${urlA}" class="onion-layer-base">
                                <img src="${urlB_Transformed}" class="onion-layer-overlay" style="opacity:${currentOnionOpacity}">
                            </div>`;
                    } else {
                        imgB_Html = `<img src="${urlB_Transformed}" style="border:2px solid var(--primary);">`;
                    }

                    // ä½¿ç”¨å¢å¼·ç‰ˆå·®ç•°æ¯”å° (HSV + å®¹éŒ¯)
                    const diffBlob = await generateDiffImage(imgObjA, transformedCanvasB);
                    diffHtml = `<img src="${URL.createObjectURL(diffBlob)}" class="diff-mark">`;
                } catch(e) { console.error(e); }
            }
            html += `<div class="diff-grid diff-row"><div style="text-align:center; font-weight:bold;">T${t}</div><div class="diff-img-wrap">${imgA_Html}</div><div class="diff-img-wrap">${imgB_Html}</div><div class="diff-img-wrap">${diffHtml}</div></div>`;
        }
        compareContent.innerHTML = html;
    }

    function createTransformedCanvas(sourceImg, angle, mirror) {
        const canvas = document.createElement('canvas');
        canvas.width = sourceImg.width; canvas.height = sourceImg.height;
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = '#ffffff';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.save(); 
        ctx.translate(canvas.width / 2, canvas.height / 2);
        if (mirror) ctx.scale(-1, 1);
        ctx.rotate(angle * Math.PI / 180);
        ctx.drawImage(sourceImg, -sourceImg.width / 2, -sourceImg.height / 2);
        ctx.restore(); 
        return canvas;
    }

    // --- ACCURACY UPGRADE: HSV Color Helper ---
    function rgbToHsl(r, g, b) {
        r /= 255, g /= 255, b /= 255;
        const max = Math.max(r, g, b), min = Math.min(r, g, b);
        let h, s, l = (max + min) / 2;
        if (max === min) { h = s = 0; } else {
            const d = max - min;
            s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
            switch (max) {
                case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                case g: h = (b - r) / d + 2; break;
                case b: h = (r - g) / d + 4; break;
            }
            h /= 6;
        }
        return [h * 360, s, l];
    }

    // --- ACCURACY UPGRADE: Robust Strategy Color Detection ---
    function isStrategyColor(r, g, b) {
        // å…ˆè½‰ HSVï¼Œå°æŠ—å…‰å½±è®ŠåŒ–
        const [h, s, l] = rgbToHsl(r, g, b);
        
        // æ’é™¤å¤ªæš—(é»‘)ã€å¤ªäº®(ç™½)æˆ–å¤ªæ·¡(ç°)çš„é¡è‰²
        if (l < 0.2 || l > 0.95 || s < 0.25) return false;

        // ç´…è‰²ç¯„åœ (è·¨è¶Š 0åº¦/360åº¦)
        const isRed = (h >= 340 || h <= 20);
        // è—è‰²ç¯„åœ (200åº¦ ~ 260åº¦)
        const isBlue = (h >= 200 && h <= 260);

        return isRed || isBlue;
    }

    // --- ACCURACY UPGRADE: Neighbor Tolerance Difference ---
    async function generateDiffImage(img1, img2OrCanvas) {
        const w = Math.max(img1.width, img2OrCanvas.width), h = Math.max(img1.height, img2OrCanvas.height);
        const c = document.createElement('canvas'); c.width = w; c.height = h; const ctx = c.getContext('2d');
        ctx.drawImage(img1, 0, 0, w, h); const d1 = ctx.getImageData(0,0,w,h);
        
        const c2 = document.createElement('canvas'); c2.width = w; c2.height = h; const ctx2 = c2.getContext('2d');
        ctx2.drawImage(img2OrCanvas, 0, 0, w, h); const d2 = ctx2.getImageData(0,0,w,h);
        
        const target = ctx.createImageData(w, h);
        const data1 = d1.data;
        const data2 = d2.data;

        // è¼”åŠ©å‡½å¼ï¼šæª¢æŸ¥æŸå€‹åƒç´ æ˜¯å¦ç‚ºç›®æ¨™è‰²
        const checkColor = (idx, data) => {
            if (idx < 0 || idx >= data.length) return false;
            return isStrategyColor(data[idx], data[idx+1], data[idx+2]);
        };

        for (let i=0; i<data1.length; i+=4) {
            // åŸºæœ¬é¡è‰²è·é›¢
            const r1=data1[i], g1=data1[i+1], b1=data1[i+2]; 
            const r2=data2[i], g2=data2[i+1], b2=data2[i+2];
            const dist = Math.sqrt((r1-r2)**2+(g1-g2)**2+(b1-b2)**2);

            let isDiff = false;
            let outputGray = true;

            if (dist > 40) { // æé«˜ä¸€é»é–¾å€¼ä»¥æŠ—å™ª
                const isTargetA = isStrategyColor(r1, g1, b1);
                const isTargetB = isStrategyColor(r2, g2, b2);

                if (isTargetA || isTargetB) {
                    // å¦‚æœæœ¬èº«æ˜¯ç­–ç•¥è‰²ï¼Œä¸”å·®ç•°å¤§ï¼Œå…ˆå‡è¨­æ˜¯å·®ç•°
                    // --- å®¹éŒ¯æ©Ÿåˆ¶ï¼šæœå°‹å‘¨åœ 3x3 åƒç´  (Neighbor Search) ---
                    // å¦‚æœåœ¨å°æ–¹åœ–ç‰‡çš„ã€Œé„°è¿‘ä½ç½®ã€æ‰¾å¾—åˆ°ç›¸åŒé¡è‰²ï¼Œè¦–ç‚ºæ‰‹éœ‡ï¼Œå¿½ç•¥å·®ç•°
                    let foundMatch = false;
                    const y = Math.floor((i/4) / w);
                    const x = (i/4) % w;
                    
                    // åªæœ‰ç•¶ã€Œæˆ‘æ˜¯ç´…/è—ã€ä½†ã€Œå°æ–¹è©²é»ä¸æ˜¯ã€æ™‚ï¼Œæ‰éœ€è¦å»æœå°‹å°æ–¹å‘¨åœæœ‰æ²’æœ‰æˆ‘
                    // é€™æ¨£å¯ä»¥é¿å…å¾®å°ä½ç§»é€ æˆçš„ "å‡æ¶ˆå¤±" æˆ– "å‡å‡ºç¾"
                    
                    const searchRadius = 1; // æœå°‹åŠå¾‘ 1px (3x3)
                    
                    for (let dy = -searchRadius; dy <= searchRadius; dy++) {
                        for (let dx = -searchRadius; dx <= searchRadius; dx++) {
                            if (dx===0 && dy===0) continue;
                            const ny = y + dy, nx = x + dx;
                            if (nx >=0 && nx < w && ny >=0 && ny < h) {
                                const ni = (ny * w + nx) * 4;
                                // æª¢æŸ¥ data2 çš„é„°å±…æ˜¯å¦è·Ÿ data1[i] é¡è‰²æ¥è¿‘
                                const nr2=data2[ni], ng2=data2[ni+1], nb2=data2[ni+2];
                                const ndist = Math.sqrt((r1-nr2)**2+(g1-ng2)**2+(b1-nb2)**2);
                                if (ndist < 40) { foundMatch = true; break; }
                            }
                        }
                        if(foundMatch) break;
                    }

                    if (!foundMatch) {
                        isDiff = true;
                        outputGray = false;
                    }
                }
            }

            if (isDiff) {
                target.data[i]=236; target.data[i+1]=72; target.data[i+2]=153; target.data[i+3]=255; 
            } else {
                const gray = (r1+g1+b1)/3; 
                target.data[i]=gray; target.data[i+1]=gray; target.data[i+2]=gray; target.data[i+3]=50; 
            }
        }
        ctx.putImageData(target, 0, 0); return new Promise(resolve => c.toBlob(resolve));
    }

    // Helpers
    function performClustering(gameIds, signatures, threshold) { const groups = []; const visited = new Set(); for (let i=0; i<gameIds.length; i++) { if(visited.has(gameIds[i])) continue; const grp = {repId: gameIds[i], members:[gameIds[i]]}; visited.add(gameIds[i]); for(let j=i+1; j<gameIds.length; j++) { if(!visited.has(gameIds[j]) && isStrategySimilar(signatures[gameIds[i]], signatures[gameIds[j]], threshold)) { grp.members.push(gameIds[j]); visited.add(gameIds[j]); } } groups.push(grp); } return groups.sort((a,b)=>b.members.length-a.members.length); }
    function isStrategySimilar(sigA, sigB, threshold) { const len = Math.min(sigA.length, sigB.length); if(len===0) return false; for(let k=0; k<len; k++) { if(sigA[k].turn!==sigB[k].turn) continue; if(hammingDist(sigA[k].hash, sigB[k].hash) > threshold) return false; } return true; }
    function showImgModal(src, text) { document.getElementById('imgModal').style.display='flex'; modalImg.src=src; modalCaption.textContent=text; }
    function loadImage(file) { return new Promise(resolve => { const img=new Image(); img.onload=()=>resolve(img); img.src=URL.createObjectURL(file); }); }
    function getRotatedHash(img) { const c = preprocessImage(img); let minH=null; for(let a of ANGLES) { const r=rotateCanvas(c,a); const h=calculateHash(r); if(minH===null||h<minH) minH=h; } return minH; }
    
    // --- ACCURACY UPGRADE: Better Preprocessing ---
    function preprocessImage(img) { 
        const s=IMG_SIZE; 
        const c=document.createElement('canvas'); 
        c.width=s; c.height=s; 
        const ctx=c.getContext('2d'); 
        
        ctx.fillStyle='#fff'; 
        ctx.fillRect(0,0,s,s); 
        
        // ç°¡å–®çš„ç¸®æ”¾é‚è¼¯ï¼Œæœªä¾†å¯åœ¨æ­¤åŠ å…¥ Auto-Crop (è‡ªå‹•è£åˆ‡)
        const sc=Math.min(s/img.naturalWidth, s/img.naturalHeight)*0.9; 
        const w=img.naturalWidth*sc; 
        const h=img.naturalHeight*sc; 
        ctx.drawImage(img, (s-w)/2, (s-h)/2, w, h); 
        return c; 
    }
    
    function rotateCanvas(s,a) { if(a===0) return s; const c=document.createElement('canvas'); c.width=s.width; c.height=s.height; const x=c.getContext('2d'); x.fillStyle='#fff'; x.fillRect(0,0,c.width,c.height); x.translate(c.width/2, c.height/2); x.rotate(a*Math.PI/180); x.drawImage(s, -c.width/2, -c.height/2); return c; }
    
    // --- ACCURACY UPGRADE: HSV-aware Hashing ---
    function calculateHash(c) { 
        const s=16; 
        const cv=document.createElement('canvas'); cv.width=s; cv.height=s; 
        const x=cv.getContext('2d'); x.drawImage(c,0,0,s,s); 
        const d=x.getImageData(0,0,s,s).data; 
        let h=""; 
        for(let i=0; i<d.length; i+=4) { 
            // ä½¿ç”¨æ–°çš„ HSV åˆ¤å®šé‚è¼¯ä¾†ç”¢ç”Ÿ Hashï¼Œè®“åˆ†ç¾¤ä¹Ÿäº«å—åˆ°é«˜ç²¾åº¦åˆ¤å®š
            const r=d[i], g=d[i+1], b=d[i+2];
            if (isStrategyColor(r,g,b)) {
                // å¦‚æœæ˜¯ç´…/è—ï¼Œé€²ä¸€æ­¥å€åˆ†
                const [hue, sat, lum] = rgbToHsl(r, g, b);
                if (hue >= 340 || hue <= 20) h+="1"; // Red
                else if (hue >= 200 && hue <= 260) h+="2"; // Blue
                else h+="3"; // Other strategy color?
            } else {
                // éç­–ç•¥è‰²ï¼Œåˆ¤æ–·é»‘ç™½
                const avg=(r+g+b)/3;
                if(avg > 200) h+="0"; // White/Empty
                else h+="3"; // Black/Ink
            }
        } 
        return h; 
    }
    
    function hammingDist(s1, s2) { let d=0; for(let i=0; i<s1.length; i++) if(s1[i]!==s2[i]) d++; return d; }
    
    downloadExcelBtn.addEventListener('click', () => { const data = []; clusteredGroups.forEach((g,i) => g.members.forEach(id => data.push({"ç­–ç•¥ç¾¤çµ„":`Pattern ${i+1}`,"è³½å±€ ID":`Game ${id}`,"åŒçµ„æˆå“¡æ•¸":g.members.length}))); const wb = XLSX.utils.book_new(); const ws = XLSX.utils.json_to_sheet(data); XLSX.utils.book_append_sheet(wb, ws, "åˆ†é¡çµæœ"); XLSX.writeFile(wb, `Game_Analysis_Final.xlsx`); });
    downloadZipBtn.addEventListener('click', async () => { downloadZipBtn.disabled = true; const zip = new JSZip(); for(let i=0; i<clusteredGroups.length; i++) { const g = clusteredGroups[i]; const pf = zip.folder(`Pattern_${i+1}_(Count_${g.members.length})`); g.members.forEach(gid => { if(gameData[gid]) { const gf = pf.folder(`Game_${gid}`); Object.values(gameData[gid]).forEach(f => gf.file(f.name, f)); }}); } try { const c = await zip.generateAsync({type:"blob"}); saveAs(c, `Classified_Games.zip`); } catch(e){} finally { downloadZipBtn.disabled = false; } });
</script>
</body>
</html>
